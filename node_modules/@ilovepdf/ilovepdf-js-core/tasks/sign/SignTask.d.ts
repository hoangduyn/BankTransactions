import Task from "../Task";
import ILovePDFTool from "../../types/ILovePDFTool";
import { TaskParams } from '../Task';
import Auth from "../../auth/Auth";
import XHRInterface from "../../utils/XHRInterface";
import { GetSignatureStatus } from "../../ILovePDFCoreApi";
import Signer from "./receivers/Signer";
export interface SignProcessParams {
    /**
     * Emails language that will be received by signers.
     */
    language?: 'EN' | 'ES' | 'FR' | 'IT' | 'JA' | 'ZH-CN' | 'ZH-TW' | 'BG';
    /**
     * If true, allow signers to sign in parallel. Otherwise, do it sequentially.
     */
    lock_order?: boolean;
    /**
     * Days until the signature request will expire.
     */
    expiration_date?: number;
    /**
     * If true, a signed certified hash and a qualified timestamp is embedded to
     * the signed documents, ensuring document and signatures integrity in the
     * future. Certified signatures are eIDAS, ESIGN & UETA compliant.
     */
    certified?: boolean;
    /**
     * Requester number to facilitate filtering.
     */
    custom_int?: number;
    /**
     * Requester string to facilitate filtering.
     */
    custom_string?: string;
    /**
     * If true, displays UUID at the bottom of the signature. Otherwise, it is hidden.
     * This has only aesthetic purposes.
     */
    uuid_visible?: boolean;
    /**
     * Enables signature reminders.
     */
    reminders?: boolean;
    /**
     * If 'reminders' is true, reminders cycle can be set.
     * 1 <= signer_reminder_days_cycle <= expiration_days.
     */
    signer_reminder_days_cycle?: number;
    /**
     * Brand name that will be displayed in emails.
     * Required if `brand_logo` is set.
     */
    brand_name?: string;
    /**
     * Brand logo that will be displayed in emails.
     * Required if `brand_name` is set.
     */
    brand_logo?: string;
}
export default class SignTask extends Task {
    type: ILovePDFTool;
    private signers;
    constructor(auth: Auth, xhr: XHRInterface, params?: TaskParams);
    process(params?: SignProcessParams): Promise<ProcessReturn>;
    /**
     * Creates a signature object as string to send to server.
     * @param params - Params to create a custom signature.
     */
    private createSignatureData;
    addReceiver(signer: Signer): void;
}
declare type ProcessReturn = GetSignatureStatus;
export {};
